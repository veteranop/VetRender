{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9f314e3b-95d6-4008-9588-b01fef6b1b83",
   "metadata": {},
   "outputs": [],
   "source": [
    "import tkinter as tk\n",
    "from tkinter import ttk, filedialog, messagebox\n",
    "import numpy as np\n",
    "import xml.etree.ElementTree as ET\n",
    "from matplotlib.figure import Figure\n",
    "from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.colors import LinearSegmentedColormap\n",
    "\n",
    "class AntennaPattern:\n",
    "    \"\"\"Handles antenna pattern data from XML\"\"\"\n",
    "    def __init__(self):\n",
    "        self.azimuth_pattern = {}  # {angle: gain_dB}\n",
    "        self.elevation_pattern = {}  # {angle: gain_dB}\n",
    "        self.max_gain = 0\n",
    "        \n",
    "    def load_from_xml(self, filepath):\n",
    "        \"\"\"Load antenna pattern from XML file\"\"\"\n",
    "        try:\n",
    "            tree = ET.parse(filepath)\n",
    "            root = tree.getroot()\n",
    "            \n",
    "            # Try to parse common XML antenna pattern formats\n",
    "            # This is a generic parser - adjust based on your specific XML format\n",
    "            \n",
    "            # Look for azimuth pattern\n",
    "            for elem in root.iter():\n",
    "                if 'azimuth' in elem.tag.lower():\n",
    "                    for child in elem:\n",
    "                        angle = float(child.get('angle', child.get('deg', 0)))\n",
    "                        gain = float(child.get('gain', child.get('db', 0)))\n",
    "                        self.azimuth_pattern[angle] = gain\n",
    "                        \n",
    "                if 'elevation' in elem.tag.lower():\n",
    "                    for child in elem:\n",
    "                        angle = float(child.get('angle', child.get('deg', 0)))\n",
    "                        gain = float(child.get('gain', child.get('db', 0)))\n",
    "                        self.elevation_pattern[angle] = gain\n",
    "            \n",
    "            if self.azimuth_pattern:\n",
    "                self.max_gain = max(self.azimuth_pattern.values())\n",
    "            \n",
    "            return True\n",
    "        except Exception as e:\n",
    "            print(f\"Error loading XML: {e}\")\n",
    "            return False\n",
    "    \n",
    "    def get_gain(self, azimuth, elevation=0):\n",
    "        \"\"\"Get antenna gain for a given azimuth and elevation angle\"\"\"\n",
    "        az_gain = self._interpolate_pattern(self.azimuth_pattern, azimuth)\n",
    "        el_gain = self._interpolate_pattern(self.elevation_pattern, elevation)\n",
    "        \n",
    "        # Combine azimuth and elevation gains\n",
    "        if az_gain is not None and el_gain is not None:\n",
    "            return az_gain + el_gain - self.max_gain  # Avoid double-counting max gain\n",
    "        elif az_gain is not None:\n",
    "            return az_gain\n",
    "        elif el_gain is not None:\n",
    "            return el_gain\n",
    "        else:\n",
    "            return 0  # Isotropic if no pattern loaded\n",
    "    \n",
    "    def _interpolate_pattern(self, pattern, angle):\n",
    "        \"\"\"Interpolate gain from pattern dictionary\"\"\"\n",
    "        if not pattern:\n",
    "            return None\n",
    "            \n",
    "        # Normalize angle to 0-360\n",
    "        angle = angle % 360\n",
    "        \n",
    "        if angle in pattern:\n",
    "            return pattern[angle]\n",
    "        \n",
    "        # Linear interpolation between nearest points\n",
    "        angles = sorted(pattern.keys())\n",
    "        \n",
    "        # Find surrounding angles\n",
    "        lower = max([a for a in angles if a <= angle], default=angles[-1])\n",
    "        upper = min([a for a in angles if a > angle], default=angles[0])\n",
    "        \n",
    "        if lower == upper:\n",
    "            return pattern[lower]\n",
    "        \n",
    "        # Handle wrap-around at 360/0\n",
    "        if upper < lower:\n",
    "            upper += 360\n",
    "            if angle < lower:\n",
    "                angle += 360\n",
    "        \n",
    "        # Linear interpolation\n",
    "        ratio = (angle - lower) / (upper - lower)\n",
    "        gain = pattern[lower] + ratio * (pattern[upper % 360] - pattern[lower])\n",
    "        \n",
    "        return gain\n",
    "\n",
    "\n",
    "class PropagationModel:\n",
    "    \"\"\"RF Propagation calculations\"\"\"\n",
    "    \n",
    "    @staticmethod\n",
    "    def free_space_loss(distance_km, frequency_mhz):\n",
    "        \"\"\"Calculate free space path loss in dB\n",
    "        FSPL(dB) = 32.45 + 20*log10(dist_km) + 20*log10(freq_MHz)\n",
    "        \"\"\"\n",
    "        if distance_km <= 0:\n",
    "            return 0\n",
    "        fspl = 32.45 + 20 * np.log10(distance_km) + 20 * np.log10(frequency_mhz)\n",
    "        return fspl\n",
    "    \n",
    "    @staticmethod\n",
    "    def calculate_received_power(tx_power_dbm, tx_gain_db, distance_km, \n",
    "                                frequency_mhz, rx_gain_db=0):\n",
    "        \"\"\"Calculate received power using Friis transmission equation\n",
    "        Pr = Pt + Gt + Gr - FSPL\n",
    "        \"\"\"\n",
    "        fspl = PropagationModel.free_space_loss(distance_km, frequency_mhz)\n",
    "        rx_power = tx_power_dbm + tx_gain_db + rx_gain_db - fspl\n",
    "        return rx_power\n",
    "    \n",
    "    @staticmethod\n",
    "    def erp_to_eirp(erp_dbm):\n",
    "        \"\"\"Convert ERP to EIRP (add 2.15 dB for dipole reference)\"\"\"\n",
    "        return erp_dbm + 2.15\n",
    "\n",
    "\n",
    "class PropagationTool:\n",
    "    def __init__(self, root):\n",
    "        self.root = root\n",
    "        self.root.title(\"RF Propagation Tool\")\n",
    "        self.root.geometry(\"1200x800\")\n",
    "        \n",
    "        self.antenna_pattern = AntennaPattern()\n",
    "        self.setup_ui()\n",
    "        \n",
    "    def setup_ui(self):\n",
    "        # Left panel - Controls\n",
    "        control_frame = ttk.Frame(self.root, padding=\"10\")\n",
    "        control_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\n",
    "        \n",
    "        # Antenna Pattern\n",
    "        ttk.Label(control_frame, text=\"Antenna Pattern:\").grid(row=0, column=0, sticky=tk.W)\n",
    "        self.pattern_label = ttk.Label(control_frame, text=\"None loaded\")\n",
    "        self.pattern_label.grid(row=0, column=1, sticky=tk.W)\n",
    "        ttk.Button(control_frame, text=\"Load XML\", command=self.load_antenna_pattern).grid(row=0, column=2)\n",
    "        \n",
    "        # ERP\n",
    "        ttk.Label(control_frame, text=\"ERP (dBm):\").grid(row=1, column=0, sticky=tk.W, pady=5)\n",
    "        self.erp_var = tk.StringVar(value=\"40\")\n",
    "        ttk.Entry(control_frame, textvariable=self.erp_var, width=15).grid(row=1, column=1, sticky=tk.W)\n",
    "        \n",
    "        # Frequency\n",
    "        ttk.Label(control_frame, text=\"Frequency (MHz):\").grid(row=2, column=0, sticky=tk.W, pady=5)\n",
    "        self.freq_var = tk.StringVar(value=\"900\")\n",
    "        ttk.Entry(control_frame, textvariable=self.freq_var, width=15).grid(row=2, column=1, sticky=tk.W)\n",
    "        \n",
    "        # Antenna Height\n",
    "        ttk.Label(control_frame, text=\"Antenna Height (m):\").grid(row=3, column=0, sticky=tk.W, pady=5)\n",
    "        self.height_var = tk.StringVar(value=\"30\")\n",
    "        ttk.Entry(control_frame, textvariable=self.height_var, width=15).grid(row=3, column=1, sticky=tk.W)\n",
    "        \n",
    "        # Max Distance\n",
    "        ttk.Label(control_frame, text=\"Max Distance (km):\").grid(row=4, column=0, sticky=tk.W, pady=5)\n",
    "        self.max_dist_var = tk.StringVar(value=\"100\")\n",
    "        ttk.Entry(control_frame, textvariable=self.max_dist_var, width=15).grid(row=4, column=1, sticky=tk.W)\n",
    "        \n",
    "        # Resolution\n",
    "        ttk.Label(control_frame, text=\"Resolution (points):\").grid(row=5, column=0, sticky=tk.W, pady=5)\n",
    "        self.resolution_var = tk.StringVar(value=\"500\")\n",
    "        ttk.Entry(control_frame, textvariable=self.resolution_var, width=15).grid(row=5, column=1, sticky=tk.W)\n",
    "        \n",
    "        # Calculate button\n",
    "        ttk.Button(control_frame, text=\"Calculate Propagation\", \n",
    "                  command=self.calculate_propagation).grid(row=6, column=0, columnspan=3, pady=20)\n",
    "        \n",
    "        # Status\n",
    "        self.status_var = tk.StringVar(value=\"Ready\")\n",
    "        ttk.Label(control_frame, textvariable=self.status_var, \n",
    "                 relief=tk.SUNKEN).grid(row=7, column=0, columnspan=3, sticky=(tk.W, tk.E))\n",
    "        \n",
    "        # Right panel - Visualization\n",
    "        viz_frame = ttk.Frame(self.root, padding=\"10\")\n",
    "        viz_frame.grid(row=0, column=1, sticky=(tk.W, tk.E, tk.N, tk.S))\n",
    "        \n",
    "        # Matplotlib figure\n",
    "        self.fig = Figure(figsize=(8, 8), dpi=100)\n",
    "        self.ax = self.fig.add_subplot(111, projection='polar')\n",
    "        self.canvas = FigureCanvasTkAgg(self.fig, master=viz_frame)\n",
    "        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)\n",
    "        \n",
    "        # Configure grid weights\n",
    "        self.root.columnconfigure(1, weight=1)\n",
    "        self.root.rowconfigure(0, weight=1)\n",
    "        \n",
    "    def load_antenna_pattern(self):\n",
    "        filepath = filedialog.askopenfilename(\n",
    "            title=\"Select Antenna Pattern XML\",\n",
    "            filetypes=[(\"XML files\", \"*.xml\"), (\"All files\", \"*.*\")]\n",
    "        )\n",
    "        if filepath:\n",
    "            if self.antenna_pattern.load_from_xml(filepath):\n",
    "                self.pattern_label.config(text=filepath.split('/')[-1])\n",
    "                self.status_var.set(\"Antenna pattern loaded successfully\")\n",
    "            else:\n",
    "                messagebox.showerror(\"Error\", \"Failed to load antenna pattern\")\n",
    "                self.status_var.set(\"Error loading antenna pattern\")\n",
    "    \n",
    "    def calculate_propagation(self):\n",
    "        try:\n",
    "            # Get parameters\n",
    "            erp_dbm = float(self.erp_var.get())\n",
    "            freq_mhz = float(self.freq_var.get())\n",
    "            height_m = float(self.height_var.get())\n",
    "            max_dist_km = float(self.max_dist_var.get())\n",
    "            resolution = int(self.resolution_var.get())\n",
    "            \n",
    "            self.status_var.set(\"Calculating...\")\n",
    "            self.root.update()\n",
    "            \n",
    "            # Convert ERP to EIRP\n",
    "            eirp_dbm = PropagationModel.erp_to_eirp(erp_dbm)\n",
    "            \n",
    "            # Create calculation grid (polar coordinates for GPU optimization)\n",
    "            azimuths = np.linspace(0, 360, resolution)\n",
    "            distances = np.linspace(0.1, max_dist_km, resolution)\n",
    "            \n",
    "            # Create meshgrid\n",
    "            az_grid, dist_grid = np.meshgrid(azimuths, distances)\n",
    "            \n",
    "            # Calculate antenna gain for each azimuth (vectorized)\n",
    "            gain_grid = np.zeros_like(az_grid)\n",
    "            for i, az in enumerate(azimuths):\n",
    "                gain_grid[:, i] = self.antenna_pattern.get_gain(az, elevation=0)\n",
    "            \n",
    "            # Calculate received power (vectorized for GPU-like performance)\n",
    "            # This uses NumPy's vectorization which can leverage SIMD and multiple cores\n",
    "            fspl_grid = PropagationModel.free_space_loss(dist_grid, freq_mhz)\n",
    "            rx_power_grid = eirp_dbm + gain_grid - fspl_grid\n",
    "            \n",
    "            # Plot results\n",
    "            self.plot_propagation(az_grid, dist_grid, rx_power_grid)\n",
    "            \n",
    "            self.status_var.set(f\"Calculation complete - EIRP: {eirp_dbm:.1f} dBm\")\n",
    "            \n",
    "        except ValueError as e:\n",
    "            messagebox.showerror(\"Error\", f\"Invalid input: {e}\")\n",
    "            self.status_var.set(\"Error in calculation\")\n",
    "        except Exception as e:\n",
    "            messagebox.showerror(\"Error\", f\"Calculation error: {e}\")\n",
    "            self.status_var.set(\"Error in calculation\")\n",
    "    \n",
    "    def plot_propagation(self, az_grid, dist_grid, rx_power_grid):\n",
    "        \"\"\"Plot propagation pattern in polar coordinates\"\"\"\n",
    "        self.ax.clear()\n",
    "        \n",
    "        # Convert azimuth to radians\n",
    "        az_rad = np.deg2rad(az_grid)\n",
    "        \n",
    "        # Create custom colormap (green to yellow to red)\n",
    "        colors = ['red', 'orange', 'yellow', 'lightgreen', 'green']\n",
    "        n_bins = 100\n",
    "        cmap = LinearSegmentedColormap.from_list('signal_strength', colors, N=n_bins)\n",
    "        \n",
    "        # Plot\n",
    "        contour = self.ax.contourf(az_rad, dist_grid, rx_power_grid, \n",
    "                                   levels=20, cmap=cmap)\n",
    "        \n",
    "        # Add colorbar\n",
    "        if hasattr(self, 'colorbar'):\n",
    "            self.colorbar.remove()\n",
    "        self.colorbar = self.fig.colorbar(contour, ax=self.ax, pad=0.1)\n",
    "        self.colorbar.set_label('Received Power (dBm)', rotation=270, labelpad=20)\n",
    "        \n",
    "        # Configure plot\n",
    "        self.ax.set_theta_zero_location('N')\n",
    "        self.ax.set_theta_direction(-1)\n",
    "        self.ax.set_ylim(0, dist_grid.max())\n",
    "        self.ax.set_ylabel('Distance (km)', labelpad=30)\n",
    "        self.ax.set_title('RF Propagation Pattern\\n(Received Power)', pad=20)\n",
    "        \n",
    "        # Add grid\n",
    "        self.ax.grid(True, alpha=0.3)\n",
    "        \n",
    "        self.canvas.draw()\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    root = tk.Tk()\n",
    "    app = PropagationTool(root)\n",
    "    root.mainloop()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c08d1486-433b-412e-a0d5-b76efe440e3c",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
